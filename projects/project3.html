<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roguelike | Jon Wich - Portfolio</title>
    <script>
        (function() {
            // Check localStorage for dark mode preference
            if (localStorage.getItem('dark-mode') === 'enabled') {
                // Add dark mode class immediately
                document.documentElement.classList.add('dark-mode');
                
                // Optional: Prevent initial flash by setting a transition delay
                document.documentElement.style.transition = 'none';
                
                // Remove the no-transition style after initial load
                window.addEventListener('load', function() {
                    document.documentElement.style.transition = '';
                });
            }
        })();
    </script>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Ribbon -->
    <header class = "navbar">
        <div class = "name"><a href="../index.html">Jon Wich</a></div>

        <!-- <div class = "project-nav"> 
            <a href="project2.html" class="nav-btn">← Previous Project</a>
            <a href="project4.html" class="nav-btn">Next Project →</a>
        </div> -->

        <nav>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../contact.html">Contact</a></li>
                <li><button id="dark-mode-toggle">Dark Mode</button></li>
            </ul>
        </nav>
     </header>

     <!-- Main -->
      <main>
        <article class="project-details">
            <h1>Roguelike Conversion</h1>

            <div class="project-image">
                <img src="../images/project3.jpg" alt="WebM Goes Here">
            </div>

            <div class="project-info">
                <div class="info-item">
                    <span class="label">Technologies:</span>
                    <span class="value">Placeholder</span>
                </div>

                <div class="info-item">
                    <span class="label">Duration:</span>
                    <span class="value">Placeholder</span>
                </div>
            </div>

            <section class="project-description">
                <h2>Project Overview</h2>
                <p><i>Brief: This mod, Dungeons of Soleanna (DoS), adds a new selectable gamemode, loading the player into a randomly generated dungeon using a 3x3 grid of rooms. To progress, the player most solve puzzles, find unique keys and defeat enemies while searching for the Boss Room.</i></p>
                <p>After years of wanting to make a Roguelike dungeon crawler, I finally decided to prototype it in the most unorthodox way possible.
                    <br><i>Sonic The Hedgehog (2006)</i> is a game infamous for its strange controls, poor performance and myriad glitches, yet under the hood it's a surprisingly capable product, boasting the most modular design of any game in the series right out of the box (at least for modders.)
                    After working with the game for years, I became well acquainted with its quirks and decided it would be a fun challenge to try and realize my Roguelike dreams by using it like a game engine.
                    <br>This required cutting out a great many features, but it forced me to truly learn all the underlying mechanics that go into making a game like this so that I could properly adapt them into such a unique environment.
                </p>
                <p><i>NOTES: No code injection was used for this project, beyond a minor patch to enable more dynamic audio. Everything was done within the game's native Lua, along with clever game object manipulation.</i>
                <br><i>This project was featured in the Sonic Hacking Contest, where it received an honorable mention for Best Technical Work and a trophy for Best Boss Design. Judge evaluations can be found <a href="https://docs.google.com/document/d/176JE5fHaicNrqXNVrKzY5RrT93H9a_K8OeXxCtK7-LU/edit?tab=t.0" target = "_blank">here.</a></i></p>

                <!-- Expandable parts! -->
                <div class="expandable-section">
                    <button class="expand-btn">Terminology</button>
                    <div class="expandable-content">
                        <p>The following are common terms used internally by the game. I will be referring to these often throughout this page.</p>
                        <ul>
                            <li>Event: A string passed to Lua by some occurrence in the game world, most commonly sent when a player enters an "eventbox" (invisible collider.) The event string, as well as behavior invoked, is entirely up to the programmer, but there are certain C methods that can be invoked directly which target objects (e.g., signaling, which destroys ObjectPhysics).</li>
                            <li>ObjectPhysics: A generic havok object. Model data, Collision and other properties are pulled from a .bin file, making it easy to create custom ones.</li>
                            <li>SET: Object layout file.</li>
                            <li>ObjID: Every object has a simple internal ID corresponding to the order it was placed in the SET. Every object also has an "ObjName" parameter which is simply a string handle. Either can be used when calling a function that targets objects.</li>
                            <li>Group: A list of objects, collected by their IDs, with a string handle. Events can target the Group Name, passing the message to every object in the group, and Groups can be assigned a function to run when every object within the Group is destroyed.</li>
                            <li>Inactive: Every object can be declared as Inactive on start. This means the object still gets loaded when constructing the stage, but it won't appear in the game world until activated by an event. Once activated, an object cannot be de-activated.</li>
                        </ul>
                    </div>
                </div>

                <div class="expandable-section">
                    <button class="expand-btn">Project Goals</button>
                    <div class="expandable-content">
                        <p>I heavily based the design on the Dungeoneering skill from <i>RuneScape</i>. While my ideal game would flesh out many of those mechanics and incorporate new ones, for this project I focused on the basics:</p>
                        <ul>
                            <li>Random, Grid Layout: A "floor" should consist of box-shaped rooms arranged on a grid, randomly connected at runtime. These rooms should be persistent so that the player can freely backtrack, so the connections have to be physical.</li>
                            <li>Varied Decoration: The interior of each room should have some random variation to it. A box on its own isn't interesting to explore, but a box segmented by crumbling wooden planks or designed like a barracks changes how you interact with it. This should change between runs to keep things fresh.</li>
                            <li>Exploratory Progression: Rooms have up to 4 doors that connect to other rooms. These doors can be locked until the player finds a unique key spawned elsewhere in the dungeon. This encourages exploring each room thoroughly and good spatial awareness as backtracking may be required.</li>
                            <li>Puzzles: Rooms may generate as "Puzzle Rooms", requiring the player to solve one of several randomly selected puzzles to unlock the doors. Puzzles can cover practically anything, as long as it's a good switch up from regular gameplay and quick to clear on repeat runs.</li>
                            <li>Boss Fight: One, mechanically interesting boss at the end of the dungeon. While Dungeoneering bosses tend to be more of one-trick minibosses, I took inspiration from MMO Raids for the final confrontation in DoS.</li>
                        </ul>
                        <p>Of course, these goals came with their own sets of challenges that had be solved beforehand, such as:</p>
                        <ul>
                            <li>Ensuring every layout can be completed.</li>
                            <li>Random generation in a game with virtually no prefab or instantiation system.</li>
                            <li>Synchronizing dungeon state in code between Lua instances.</li>
                        </ul>
                        <p>The rest of this page will focus on the steps taken to solve these problems and implement these goals.</p>
                    </div>
                 </div>

                <div class="expandable-section">
                    <button class="expand-btn">Breaking Sandboxing</button>
                    <div class="expandable-content">
                        <p>While Sonic 06 uses Lua for everything from stage creation to enemy behavior, it does not fully implement the language. Instead, Sonic Team decided to spin up different instances of Lua for each part of the game that uses it, then only expose whatever C-side functions were strictly necessary. While understandable, this means that generally the only part of Lua's standard libraries or functions available is the Math library.
                            <br>Out of the 6 or so Lua instances that Sonic 06 creates, only three were important for this project.
                        </p>
                        <ul>
                            <li>Mission Instance</li>
                            <ul>
                                <li>High level component of level progression.</li>
                                <li>Contains functions to manage NPC dialogue flow, display text boxes or other UI elements, and read certain flags from save data.</li>
                                <li>Mission scripts support intercepting events and incoming textboxes by adding "on_hint" and "on_event" functions. The string associated with the hint/event gets passed to the corresponding function.</li>
                            </ul>

                            <li>Enemy Instance</li>
                            <ul>
                                <li>Scripts containing enemy behavior. Contains generic functions acting as state templates (OnDamage, Update, Appear, etc.), allowing the author to create specific action sequences.</li>
                                <li>Supports functions to manipulate the camera, move the player, call textboxes, instantiate ObjectPhysics at coordinates, check if certain ObjectPhysics exist in the SET, and more.</li>
                                <li>The Enemy game object simply points to a table entry from one of these scripts, so it's trivial to create custom enemy behavior.</li>
                            </ul>
                            
                            <li>Stage Instance</li>
                            <ul>
                                <li>Lower level component of level progression.</li>
                                <li>Has access to most standard Lua libraries and functions (String, Package and Debug are excluded).</li>
                                <li>Supports functions for interacting directly with the SET/stage, such as activating or sending pre-defined messages to objects and playing sound effects.</li>
                                <li>Events are passed to a "ProcessMessage" function by their string.</li>
                            </ul>
                        </ul>
                        <p>It's easy to imagine how much can be done through Lua using these instances, but the trouble is getting them to communicate as they're completely separated internally.
                            <br>Thankfully, this is easier than it might sound. Sonic 06 has a volume object called "ScoreCollision", which targets an ObjectPhysics by its type (e.g., WoodBox, Barrel, BreakRoad) and destroys it upon entry, granting the player some points and passing a message to Lua called "Add_(Destroyed_Obj_Type)". The key is that since this is an event, it gets passed to both the Stage and Mission instances, and since it's invoked with an object, both the Enemy and Stage instances can decide when that fires (either by instantiating an object into a collider or activating a pre-placed one, respectively).
                            <br>Furthermore, enemies can pass more sophisticated messages to the Mission environment by simply calling a textbox. The string invoked will be passed to the Mission's "on_hint" function, where it works as any other argument to a function. The textbox that would've been called can even be entirely ignored.
                        </p>

                        <p>Here's an example using a locked door. </p>
                            <ul>
                                <li>Doors in 06 are just game objects that can be opened or closed using an event or a function from the Stage instance.</li>
                                <li>In DoS, doors can require a "key" to open, which is randomly selected and spawned elsewhere in the dungeon. When a key is collected, it will appear on the HUD, and when it's used it will disappear.</li>
                                <li>When the player gets near a locked door, it should either consume the key and open or display a textbox saying which key is required.</li>
                            </ul>
                            <p>The trouble with this is the textbox and HUD. I store dungeon information in the Stage instance, so it's easy to track if the player has collected a key and consume it to open doors (using the Lua function), but Stage can't handle UI or invoke text; Mission is needed for that.
                                <br>It's not feasible to tell Mission how the entire dungeon generated, but it's not unreasonable to send a small piece of information the moment it's needed.
                            </p>
                            <p>In the Mission script, I set up a table containing an array holding basic Room objects. Each Room has four entries for doors, paired to a blank string by default. In the SET, I have eventboxes in each room (to track which room the player is in) and an eventbox by each door that generated, so using the two it's easy to infer which door the player is near. Whenever one of these Door events is passed, the Mission instance checks if there's an associated string and uses it to call a textbox if needed.
                                <br>When the player hits a Door eventbox, the Stage instance checks if that door is locked. If it is, it checks if the corresponding Key variable is set. If it isn't, it activates a unique object that's been placed inside a score collider. This sends a message to the Mission instance which then updates the door's blank string to be that key hint and invokes it. Now, whenever the player enters that eventbox without the key, the Mission script simply calls the paired string.
                            </p>
                            <p>As for the UI, that required incorporating enemies.
                                <br>There's an unused function available to the Mission instance which can call one of 9 sprites to display on the HUD, based on the string provided. The graphic file is missing from the game, but we have the tools to create one from scratch, so I opted to use that to display the player's currently held keys.
                                <br>The trouble is, the function has to be called repeatedly to keep the HUD elements on screen, so I needed a way to loop the event and terminate on-demand. Activating an object in a score collider wasn't practical since that requires placing the objects ahead of time, so the loop couldn't be maintained indefinitely.
                                <br>Instead, I decided to designate a custom enemy as a Key Manager. 
                            </p>
                            <p>The Enemy instance is still separate from Stage, which is where the actual keys are stored, but enemies can detect certain ObjectPhysics in a SET by their name, so I used that quirk to track the state of each key.
                                <br>Each key has two ObjectPhysics assigned out of bounds, with one enemy constantly checking all of them. If the first Object gets destroyed (signaled when a key is collected), the enemy begins calling a hint message which Mission intercepts and uses to spawn the HUD element. This also clears that key's hint if it was paired to a door in Mission.
                                <br>If the second Object gets destroyed (signaled when the player unlocks the door), the enemy simply stops calling the hint message.
                            </p>
                            <video
                                controls
                                preload="none"
                                poster="../images/rogue_images/key_poster.png">
                                <source src = "../webms/rogue/key_req.webm" type = "video/webm">
                            </video>
                    </div>
                </div>

                <div class="expandable-section">
                    <button class="expand-btn">Loading The Dungeon</button>
                    <div class="expandable-content">
                        <p>It's quite common for Roguelikes to generate a layout by simply stitching together pre-fabricated rooms. While this is essentially how I wanted to handle generation as well, Sonic 06 has no concept of pre-fabs, let alone dynamic object movement or exposing instantiation to Lua; at best you can spawn ObjectPhysics at coordinates using an enemy, but that doesn't even allow rotation.</p>
                        <p>Since randomy spawning <i>rooms</i> was out of the question, I decided to randomize the <i>connections</i> between them. This means the walls and floor (both made using ObjectPhysics) for every room are loaded for every run, but on each side of the room, both a wall and a door exist in an Inactive state. When the dungeon generates, it goes to each of these connections and decides whether to activate the door or the wall. 
                            <br>This means that while most dungeons will have all 9 playable rooms, it's entirely possible to generate with fewer rooms, and the experience will feel fresh regardless as the way each room connects changes every time.
                        </p>
                        <p>For the most part, this step is just a coin flip per edge on the graph, but there are a couple quirks. I bias towards spawning at least 2 connections for the rooms in the middle column of the grid, though it isn't guaranteed, and edges on the corner of the grid will always generate as walls. 
                            <br>Additionally, some strange room spawns are possible, like a dead-ending puzzle room, or being able to circumvent the need for a key with a longer route (though that isn't necessarily a bad thing).
                            <br>Still, these oddities are rather uncommon, so this method works well given the limitations of the game.
                        </p>
                        <p>Interior layouts are handled in a similar manner. Rooms have up to 4 "design layouts" that they can load. These are pre-made arrangements of objects and enemies, all set to Inactive and placed in a group then copy-pasted for each room. As part of the generation step, each room will randomly select a design's Group Name to load from a table then simply activate the group.
                            <br>Puzzles support a similar system where they're assigned valid rooms to generate in. If a room is chosen to spawn as a puzzle room, it'll randomly select an available puzzle for that room and load that design as its room layout instead.
                            <br>Every room also has a "Spawn" layout which will take precedence if that's chosen as your initial room for the run and a "Boss" layout containing a portal to the final encounter.
                            <br>This system does incur additional loading when you first enter a dungeon due to the larger SET file, so I had to limit how much detail I placed in each design layout, but it's completely seamless afterward; after loading, you can restart the level as many times as you like to generate new layouts without any delay.
                        </p>
                        <video
                            controls
                            preload="none"
                            poster="../images/rogue_images/room_poster.png">
                            <source src = "../webms/rogue/spawn_random.webm" type = "video/webm">
                        </video>
                        <p>Unfortunately, this system wouldn't have been viable for the keys. Even with a preloaded 3x3 layout in mind, I tried to design every system to be easily extendable to an arbitrary dungeon size. Since there are 8 unique keys, placing each one in an Inactive state for every room was simply out of the question.
                            <br>Rather, I gave every room one key (set to Inactive) which would send a generic "GetKey" event when collected. Internally, I assign a string to a room for the key that generated within it, so when GetKey is passed I simply check which key is associated with the current room and award that to the player. This does have a downside where each room only supports one key, but that's far from an insurmountable issue.
                        </p>
                    </div>
                </div>

                <div class="expandable-section">
                    <button class="expand-btn">Generation Process</button>
                    <div class="expandable-content">
                        <p>Dungeon generation is primarily handled inside the Stage instance, where I set up an array containing a number of "room objects." Each of these objects contains some basic information (room name, number, type, etc.) as well as an array holding the room numbers for each of its borders, the status/type of its own doors, and some fields for unique background music or lighting. 
                            <br>The other steps in the generation process focus on populating the room objects and creating an array of ObjNames to activate. Once a candidate dungeon has been created, I run a pathfinding algorithm to verify it can be completed, then either activate all the necessary objects or restart the generation step from scratch until it succeeds.
                        </p>
                        <p><i>Generation Order</i></p>
                        <ol>
                            <li>Create room object.</li>
                                <ol>
                                    <li>Determine column in the grid.</li>
                                    <li>Calculate neighboring room IDs based on current row and column. Since this is a 3x3 layout, the first 3 IDs are in the bottom row while the last 3 are in the top. Anything else is considered a middle row.</li>
                                </ol>
                            <li>Iterate throw the room object array to establish connections between rooms.</li>
                                <ol>
                                    <li>Force edges on the border of the grid to generate as walls.</li>
                                    <li>For the rest, make note of the current candidate and the adjoining candidate.</li>
                                    <li>If an edge is marked to spawn a door or wall already, do so then continue the loop (this ensures you never have a door connecting to a wall).</li>
                                    <li>Otherwise, flip a coin to determine whether the connection should be a door or a wall, adding the relevant name to the ObjName array and marking the adjoining edge to spawn this way as well.</li>
                                </ol>
                            <li>Ensure at least 1 connection between rooms. This doesn't prevent a small set of rooms from generating without connections to the larger dungeon, but it ensures there are no isolated nodes.</li>
                            <li>Set the Room Type field for each room object.</li>
                                <ol>
                                    <li>Randomly select one room as the Spawn Room and another as the Boss room. These can generate anywhere, though the boss room cannot be in the middle of the grid.</li>
                                    <li>For the rest, roll a number between 1 and 100.</li>
                                    <li>If the maximum number of puzzle rooms hasn't been spawned, there's a 45% chance a room will be set as a Puzzle Room, where it will randomly select a puzzle available to that room ID. A reference to that puzzle object is then assigned to the room object.</li>
                                    <li>Otherwise, mark the room as Standard and select a design layout.</li>
                                </ol>
                            <li>Iterate through every edge of every room and select a door type for each.</li>
                                <ol>
                                    <li>If the Room Type is "Spawn", the door is unlocked, meaning it will open when the player approaches.</li>
                                    <li>If the Room Type is "Boss",  the door is unlocked, but the player will receive a warning message if they unlock the door early (originally, the door would remain locked until a certain number of rooms had been explored).</li>
                                    <li>If the Room Type is "Puzzle", the door is locked until the player clears a puzzle. If approached from a hallway, however, the door will open (to provide access in the first place).</li>
                                    <li>If the Room Type is "Standard", 75% of the time it'll be a "Guardian" door, requiring all enemies in the room to be defeated. If that fails (and the maximum number of locked doors hasn't been reached), 60% of the time it will be "Key" door, requiring a key to open. Otherwise, the door will generate as unlocked.</li>
                                </ol>
                            <li>Set the status of each door as either True or False based on whether it spawned as a door or a wall, informing the next step whether an edge should be considered when pathfinding.</li>
                            <li>Run the pathfinding algorithm to ensure a valid layout has been spawned, restarting the generation process if one cannot be found.</li>
                            <li>Go through the ObjName array and activate everything within it.</li>
                        </ol>
                    </div>
                </div>

                <div class="expandable-section">
                    <button class="expand-btn">Preventing Impossible Dungeons</button>
                    <div class="expandable-content">
                        <p>The biggest issue with any randomly generated playing field is making sure it's actually, well, playable. In DoS, I randomly select one room as the Spawn room and another as the Boss room. Since I just randomize connections instead of generating rooms in a continuous path, I knew I'd need to take some basic measures to ensure a route from spawn to the boss, but the bigger problem was the key system.</p>
                        <p>Because every locked door requires a unique key, I needed to somehow ensure that every necessary key between the Spawn Room and the Boss Room would generate in a room the player could somehow access, a problem further complicated by the (up to) four uniques entryways each room can have.</p>
                        <p>Thus, I decided to write a pathfinding algorithm that could navigate my dungeon - as it generated in Lua - from the Spawn Room to the Boss Room, keeping track of any visited rooms along the way. That way, if it encountered a locked door it could simply assign it an available key then pair that key to one of its visited rooms.
                            <br>Now, there are a great many options for very smart pathfinding in video games, and since I would be applying it to such a modest graph, there were practically no optimization concerns to speak of.
                            <br>But I didn't want a smart algorithm. I wanted a rather stupid one. Less A*, more C+.
                        </p>
                        <p>Since my dungeons had relatively few rooms and a compact design (i.e., minimal distance between any node on the graph), any sort of efficient algorithm would likely make things too simple. I wanted to ensure a minimum length "critical path" (the route between Spawn and Boss) of 5 rooms, and I wanted to allow dead-ends inside that route to create a more immersive dungeon.
                            <br>Since I'd need to customize whatever algorithm I went with to handle my key needs, I decided to try writing my own with some basic recursion. This is what I came up with:
                        </p>
                        <ul>
                            <li>Each room has an internal ID. Supply the function with the start room and target room (e.g., <code>FindPath(1,9)</code>).</li>
                            <li>Check the connections available to your current room. Prioritize whichever room number is closer to your goal.</li>
                            <ul>
                                <li>E.g., if the connections available are Room 6 and Room 2, and the target is Room 5, it'll choose Room 6 as that's closer numerically, even if Room 5 borders both on the graph.</li>
                                <li>In the case of equal weights (Target room 7, connections to 6 and 8), it'll check if either option has a direct connection to the target. If neither does, it flips a coin.</li>
                                <li>If every connection were available, this would always ensure the shortest path through the dungeon. Since that will almost never be the case, this introduces some natural variance in the route while still <i>technically</i> aiming for the shortest path.</li>
                            </ul>
                            <li>Whenever a new room is visited, add it to the "Critical Path" array.</li>
                            <li>The previous room cannot be immediately revisited unless there are no other options.</li>
                            <li>If the above occurs, or the algorithm finds itself in a room it has already visited <i>and</i> that only connects to other visited rooms, blacklist said room.</li>
                                <ul>
                                    <li>Blacklisted rooms are no longer considered as possible connections by the algorithm.</li>
                                </ul>
                            <li>When taking a step between rooms, check if either the current door or the connecting door generated as "Locked" and spawn a key using a room from the Critical Path as needed.</li>
                            <li>If the goal is encountered too early, step backwards and attempt to path to a new node until the Critical Path array has at least 5 elements.</li>
                            <li>If every available room in the dungeon is blacklisted, or if it takes too long to find a route (50 steps), abort entirely and regenerate the dungeon.</li>
                        </ul>
                        <p>Because the actual objects comprising the dungeon layout are all loaded ahead of time, just in their Inactive state, I can easily reroll dungeons by storing their Obj/Group Names and only Activating them if a dungeon generates successfully.
                            <br>If it fails for any reason, every step can be redone in an instant because nothing physically changed the in game world.
                        </p>
                    </div>
                </div>

                <div class="expandable-section">
                    <button class="expand-btn">Puzzle System</button>
                    <div class="expandable-content">
                        <p>Test</p>
                    </div>
                </div>
            </section>
        </article>
      </main>

      <footer>
        <div class="footer-content">
            <div class="footer-nav-left">
                <a href="project2.html" class="footer-nav-btn">← Previous Project</a>
            </div>

            <div class="footer-copyright">
                <p>&copy; 2025 Jonathan Wich. All rights reserved.</p>
            </div>

            <div class="footer-nav-right">
                <a href="project4.html" class="footer-nav-btn">Next Project →</a>
            </div>
        </div>
     </footer>

     <script src="../js/script.js"></script>
</body>
</html>