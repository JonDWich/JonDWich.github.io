<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics | Jon Wich - Portfolio</title>
    <link rel="stylesheet" href="../css/style.css">

    <!-- Lua highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lua.min.js"></script>
</head>
<body>
    <!-- Ribbon -->
    <header class = "navbar">
        <div class = "name">Jon Wich</div>

        <div class = "project-nav"> 
            <a href="project4.html" class="nav-btn">← Previous Project</a>
            <a href="project2.html" class="nav-btn">Next Project →</a>
        </div>

        <nav>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../contact.html">Contact</a></li>
            </ul>
        </nav>
     </header>

     <!-- Main -->
      <main>
        <article class="project-details">
            <h1>Physics Overhaul</h1>

            <div class="project-image">
                <img src="../images/project1.jpg" alt="WebM Will Go Here">
            </div>

            <div class="project-info">
                <div class="info-item">
                    <span class="label">Technologies:</span>
                    <span class="value">Placeholder Text</span>
                </div>

                <div class="info-item">
                    <span class="label">Duration:</span>
                    <span class="value">Placeholder text</span>
                </div>
            </div>

            <section class="project-description">
                <h2>Project Overview</h2>
                <p>In a long running series of high speed, physics based platformers that let the player use the terrain to fling themselves through levels, <i>Sonic The Hedgehog (2006)</i> is notable for lacking almost all of that.</p>
                <p>Slopes don't affect your speed, leaving the ground locks you to a pre-set speed, there's no momentum or inertia, characters turn on a dime without slowing down, and plenty of other staples are simply absent from this title.<br>
                    For years, overhauling the controls was a pipedream, but in early 2024 the modding scene saw a breakthrough which allowed manipulating pointer data directly through the game's native Lua framework, 
                    so as a showcase of this new tech, I began implementing a physics system for character movement, and over time the project grew to include restoring cut content,
                    fixing broken features, and even adding new ones to polish up the entire experience.
                </p>
                <p>While a proper deep dive is outside the scope of this page, I've included some of the more interesting challenges below.
                </p>
                <!-- Expandable parts! -->
                 <div class="expandable-section">
                    <button class="expand-btn">Project Goals</button>
                    <div class="expandable-content">
                        <p>In character movement, "physics" are somewhat loose; mechanics are often fudged (or even excluded) to create a smoother player experience, so I had to decide what to even implement in the first place.
                        After analyzing other games in the series, I settled on the following core mechanics:</p>
                        <ul>
                            <li>"Slope Physics": Running uphill should slow you down and vice versa. This should also apply if you jump off a slope, increasing or decreasing your jump height respectively. This is absent in the Retail game.</li>
                            <li>Momentum/Inertia: Speed should be preserved between actions/states. In Retail, the player typically snaps between pre-determined values.</li>
                            <li>Slope Launches: Related to the above, when the player runs off an incline, they should receive an upward/downward boost based on speed and angle, creating a natural launch.</li>
                            <li>Rotation Dampening: Turning resistance should increase directly with speed, and speed should decrease during sharp turns. The former somewhat exists in Retail, but it's a static resistance and negligible.</li>
                        </ul>
                        <p>Additional features were added as the project continued, such as different physics when rolling and balancing mechanics for rail grinding, but the four listed above form the foundation for everything else.</p>
                    </div>
                 </div>

                 <div class="expandable-section">
                    <button class="expand-btn">Reverse Engineering</button>
                    <div class="expandable-content">
                        <p>
                            <i>NOTE: While SEGA/Sonic Team has a very friendly relationship with modders and projects like these, I'll be omitting a lot of information about the reverse engineering process out of respect.</i> 
                        </p>

                        <p>
                            When it came to disassembling the game's code and reverse engineering the structure, my contributions were limited. Another member of the community (the one who set up our DLL system in the first place) generally took care of that.
                            <br>For my part, I focused on finding specific variables and how they were used, such as documenting all the character-specific flags or hunting down parameters stored in submodules rather than on the character themselves.
                        </p>

                        <p>The process was pretty similar to poking around in cheat engine, except I used Lua and a disassembler.
                            <br>Typically, I would use Lua to get the address of a pointer to some common structure I wanted to investigate, then I would jump to that address using a disassembler. From there, I'd look for any bytes, floats or other promising values, make note of the offsets, then retrieve them back in Lua and poke at the data until I could figure out what it handled.
                            <br>Thankfully, the guess-and-check part wasn't always needed. Since so many character parameters and modules are set up and called from Lua, I could just search for a string using the disassembler then check its relation to the player object and see how its value was assigned.
                        </p>
                        <p>For example, most character attacks are set up using "weapons modules." These are loaded via Lua in the player's script, so the variables for attack damage and whatnot are written along with everything else, but internally the data is held inside the module, not on the player object.
                            <br>Thankfully, each module has a string associated with it, and the DLL implements a function that returns a pointer to a given module using that string. Thus, if I wanted to modify the Homing Attack's damage value, the process would go like this:
                            <ul>
                                <li>Search the executable for the "c_homing_damage" string.</li>
                                <li>Check which subroutines load the string (the same string can be used in multiple modules, so I need to get the right one.)</li>
                                <li>Make note of the offset used to store the variable.</li>
                                <li>Jump out of the subroutine, back to the main module.</li>
                                <li>Each module stores this, and other related subroutines, inside a VFTable. Make note of the offset inside the table to access the subroutine.</li>
                            </ul>
                            Putting it all together, in Lua that would look like this:
                        </p>
                        <pre><code class="language-lua">
                            -- Examples, not the actual offsets
                            local vft_offset = 0x2C
                            local variable_offset = 0xF3
                            local homing_damage = PlayerObject:GetIPluginByName("homing"):Move(vft_offset + variable_offset):GetDWORD()
                        </code></pre>
                        <p>(In the actual project I properly stored this information in a table then wrote a function to easily get/set data from any module.)
                            <br>This wasn't used terribly often for the core behavior outlined in the Project Goals, but it was used extensively when I began doing character-specific tweaks later in the project.
                        </p>
                    </div>
                 </div>

                 <div class="expandable-section">
                    <button class="expand-btn">Technical Challenges</button>
                    <div class="expandable-content">
                        <p>Typically, an overhaul like this would involve extensive code injection (making the game load a DLL where you can write your own C++ code, hooking existing game functions and whatnot). <br>
                        This is possible in Sonic 06, it's how we can access pointers via Lua in the first place, but creating one is a rather involved process and requires some software that's quite hard to come by. 
                        The method used for it also only supports loading one DLL at a time, meaning mods could run into compatibility issues if the community starts using their own DLLs in their projects.</p>

                        <p>With that in mind, I decided to write this project in Lua.</p>
                        <p>The advantages to running everything through the game's Lua were that I sidestepped DLL compatibility concerns and gained a few other perks, such as faster prototyping (functions could be modified or added on the fly since nothing is compiled) and full compatibility with any patches or other mods that may edit character behavior through the executable. 
                            It also provided a chance to make modding the game more accessible as Lua is a very beginner friendly language. I wrote a library alongside the project, allowing one to easily modify character attributes, adjust hitboxes, and more as well as a framework for creating new character states and modifying existing ones.</p>
                        
                        <p>Unfortunately, using Lua meant I was completely beholden to the game's existing behavior. My mod acts like a layer sitting on top of the code in the executable; while it can utilize existing systems, and even implement new ones for its own use, it can't change what it's sitting on. 
                            For example, when you jump, the game snaps you to a set horizontal speed defined in a parameter file. This state performs that snap every frame while you remain in it, meaning if I tried to write to your horizontal speed value, my change would get ignored, and since the state is lower level than my script, I couldn't easily change the behavior.</p>
                        <p>To fix this, I instead located where values from that parameter file were stored in memory, placed their offsets into a table, then wrote functions for getting and setting the values by name. 
                            From there, I could simply update the corresponding value as you run along the ground, and the game would keep you at the correct speed when you enter the air, with aerial deceleration happening by lowering the value.
                        </p>
                        <!-- <img src="../images/physics_images/physics_airdecel.png" alt="Air Deceleration code example"> -->

                        <pre><code class="language-lua">
                            function ManageAirDeceleration(state_check)
                                local max_jump = player_reference.base_jump_speed -- Amount of vertical speed normally applied while jumping.
                                
                                -- Handles regulating air speed during or after certain gimmicks
                                if (state_check == StateID.SPRING or state_check == StateID.ROPE) and GetInputLockout() == 0 and GetPlayerSpeed("x", true) == 0 then
                                    SetPlayerLuaValue("c_jump_run", 900)
                                    SetPlayerLuaValue("c_jump_walk", 150)
                                    SetPlayerLuaValue("c_jump_speed", player_reference.base_jump_speed)
                                elseif CheckAirBlacklist(state_check) then
                                    SetPlayerLuaValue("c_jump_run", 900) -- Max horizontal air speed from a non-stationary jump
                                    SetPlayerLuaValue("c_jump_walk", 150) -- Max horizontal air speed from a stationary jump
                                    SetPlayerLuaValue("c_jump_speed", player_reference.base_jump_speed) -- Vertical boost
                                    return
                                end
                                -- A "pushback" can be replicated (at least when walking) by removing the < 0 check and taking the abs of GetPlayerSpeed("total")
                                local total = GetPlayerSpeed("total")
                                jump_run_current = total
                                if GetPlayerSpeed("x", true) < 0 then
                                    SetPlayerSpeed("x", 0, true)
                                end
                                if IsStickNeutral() then -- Quickly drop to 0 if you release the left stick
                                    jump_run_current = lerp(jump_run_current, 0, 2.5/60)
                                elseif jump_run_current > player_reference.slope_params.base_jump_run then -- If above regular jump speed, decelerate to it.
                                    jump_run_current = lerp(jump_run_current, player_reference.slope_params.base_jump_run, 1.1/60)
                                elseif jump_run_current < player_reference.slope_params.base_jump_run then -- If below regular jump speed, accelerate to it.
                                    jump_run_current = lerp(jump_run_current, player_reference.slope_params.base_jump_run, 1.5/60) -- 2
                                end
                                local jump_vert = GetPlayerLuaValue("c_jump_speed") -- Vertical speed during a jump
                                if jump_vert > max_jump then
                                    jump_vert = lerp(jump_vert, max_jump, 0.75/60)
                                end
                                local shrink_on = GetPlayerName() == "sonic" and GetContextFlag("IsShrink") or nil
                                if shrink_on then
                                    local gem_spd = total - (total * PlayerList.sonic.sonic_gem_params.purple.air_drag_rate)/60
                                    if state_check == StateID.GEM_PURPLE then
                                    SetPlayerSpeed("x", gem_spd, false)
                                    SetPlayerLuaValue("c_jump_run", jump_run_current)
                                    SetPlayerLuaValue("c_jump_walk", jump_run_current)
                                    else
                                    if jump_run_current > gem_spd - 0.1 then gem_spd = jump_run_current end -- This prevents decelerating towards 0 when airborne and shrunk
                                    SetPlayerLuaValue("c_jump_run", gem_spd - 0.1)
                                    SetPlayerLuaValue("c_jump_walk", gem_spd - 0.1)
                                    end
                                else
                                    if state_check == StateID.GEM_PURPLE and GetPlayerName() == "sonic" then -- Rouge also uses this state, weirdly, so we need to check.
                                    SetPlayerSpeed("x", jump_run_current, false)
                                    end
                                    SetPlayerLuaValue("c_jump_run", jump_run_current)
                                    SetPlayerLuaValue("c_jump_walk", jump_run_current)
                                end
                                SetPlayerLuaValue("c_jump_speed", jump_vert)
                                if state_check == StateID.JUMP and GetInput("a", "hold") then
                                    SetPlayerSpeed("y", jump_vert, false) -- This causes water bounce, maybe remove?
                                end
                                
                                SetPlayerLuaValue("c_run_speed_max", mMax(jump_run_current, player_max_run)) -- Carries air speed into the ground when landing
                            end
                        </code></pre>
                    </div>
                 </div>

                 <div class="expandable-section">
                    <button class="expand-btn">Implementation Challenges</button>
                    <div class="expandable-content">
                        <p>While the game's inherent quirks caused the most issues, there was also the problem of simply attaining the data I needed to make this work. 
                            <br>Luxuries such as local coordinates, vector and quaternion math functions, or even checking if the player is grounded, are not provided (unlike Unity or another engine), so they all have to be implemented by hand.
                            <br>A few things were just a matter of reverse engineering (such as ground checks - there's a bitfield that stores ground/air flags), but I often had to thoroughly research the math behind functions so I could implement them myself, or come up with alternative solutions using the data I already had.
                        </p>

                        <p>For instance, the first feature I worked on were the slope physics. At the time, I could read/write to the player's speed (forward/upward velocity, to be precise), I could check their global coordinates, and I could detect if they were grounded, but I couldn't get any other information about the surface they were on. Detecting slopes was easy enough, I could just check the change in the player's Y coordinate while they were grounded, but getting the exact angle of incline was another matter.
                            <br>I had a vague understanding that this was typically done with fancy calculations involving the ground normal, but this was long before I could get the vector for that, let alone do the math. 
                        </p>

                        <p>Rather, I realized I could approximate an angle by normalizing the velocity of the Y coordinate with the player's forward velocity then scaling by 90 (the maximum angle the player may encounter outside of scripted sections.) The solution wasn't perfect (the reported angle would change if they ran diagonally on an incline, for example, and I chose to normalize against max velocity instead of current velocity), but it was consistent enough to let me implement the mechanic in a way that felt natural.</p>
                        <video
                            controls
                            preload="none"
                            poster="../images/physics_images/flc_poster.png">
                            <source src = "../webms/flc_slope.webm" type = "video/webm">
                        </video>
                    </div>
                 </div>
            </section>
        </article>
      </main>

      <footer>
        <div class="footer-content">
            <div class="footer-nav-left">
                <a href="project4.html" class="footer-nav-btn">← Previous Project</a>
            </div>

            <div class="footer-copyright">
                <p>&copy; 2025 Jonathan Wich. All rights reserved.</p>
            </div>

            <div class="footer-nav-right">
                <a href="project2.html" class="footer-nav-btn">Next Project →</a>
            </div>
        </div>
     </footer>

     <script src="../js/script.js"></script>
</body>
</html>